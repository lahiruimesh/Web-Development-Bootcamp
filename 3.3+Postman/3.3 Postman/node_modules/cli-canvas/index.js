const readline = require("readline");
const lineUtils = require("./lineUtils")

class Context {

  constructor() {

    this.out = process.stdout;

    this.events = {};

    this.emptyCell = " ";

    this.style = new Style({});

    this.updateSize();
    this.configureOutputTerminal();

  }

  updateSize() {

    this.width = this.out.columns;
    this.height = this.out.rows;

    this.transform = {
      x: 0,
      y: 0
    }

    this.buffer = this.makeBuffer(this.width, this.height);
    this.nextBuffer = this.makeBuffer(this.width, this.height);

    this.clear();

    if(this.events.resize) {

      this.events.resize();

    }

  }

  on(event, callback) {

    this.events[event] = callback;

  }

  point(x, y, character) {

    character = String(character);
    x = Math.round((x - this.transform.x));
    y = Math.round((y - this.transform.y));

    if(x >= 0 && x < this.width && y >= 0 && y < this.height) {

      let out = "";

      if(this.style.foreground != Style.Color.Default) {

        out += this.style.foreground;

      }

      if(this.style.background != Style.Color.Default) {

        out += this.style.background;

      }

      out += character[0];

      this.nextBuffer[x][y] = out + Style.Color.Reset;

    }

  }

  line(x, y, width, height, character) {

    // Determine min and max x
    let xMin = Math.min(x, x + width);
    let xMax = Math.max(x, x + width);
    let yMin = Math.min(y, y + height);
    let yMax = Math.max(y, y + height);

    character = character || this.style.line;

    if(width == 0 || height == 0) {

      if(width == 0) {

        for(let pointY = yMin; pointY < yMax; pointY ++) {

          this.point(x, pointY, character);

        }

      } else {

        for(let pointX = xMin; pointX < xMax; pointX ++) {

          this.point(pointX, y, character);

        }

      }


    } else {

      let line = lineUtils.lineFromRect(x, y, width, height);

      for(let pointX = xMin; pointX < xMax; pointX += Math.min(Math.abs(line.m), Math.abs(1/line.m))) {

        let pointY = lineUtils.yAtX(line, pointX);

        this.point(Math.round(pointX), Math.round(pointY), character);

      }

    }

  }

  rect(x, y, width, height) {

    this.line(x, y, width, 0, this.style.top);
    this.line(x, y + height - 1, width, 0, this.style.bottom);

    this.line(x, y, 0, height, this.style.left);
    this.line(x + width - 1, y, 0, height, this.style.right);

    this.point(x, y, this.style.topLeft);
    this.point(x + width - 1, y, this.style.topRight);
    this.point(x, y + height - 1, this.style.bottomLeft);
    this.point(x + width - 1, y + height - 1, this.style.bottomRight);

  }

  filledRect(x, y, width, height, fillCharacter, lineCharacter) {

    lineCharacter = lineCharacter || this.style.line;
    fillCharacter = fillCharacter || this.style.fill;

    this.rect(x, y, width, height, lineCharacter);
    for(let py = y + 1; py < y + height - 1; py++) {

      this.line(x + 1, py, width - 2, 0, fillCharacter);

    }

  }

  text(x, y, str) {

    for(let i = 0; i < str.length; i++) {

      this.point(x + i, y, str[i]);

    }

  }

  clear() {

    readline.cursorTo(this.out, 0, 0);
    readline.clearScreenDown(this.out);

  }

  makeBuffer(width, height, emptyCell) {

    let buffer = new Array(width);
    for(let x = 0; x < buffer.length; x++) {

      buffer[x] = new Array(height);
      buffer[x].fill(emptyCell || this.style.empty);

    }

    return buffer;

  }

  begin() {

    this.nextBuffer = this.makeBuffer(this.width, this.height);

  }

  end() {

    let toRender = this.getBufferDifference(this.buffer, this.nextBuffer);

    for(let x = 0; x < toRender.length; x++) {

      for(let y = 0; y < toRender[x].length; y++) {

        if(toRender[x][y] != Context.unchangedCell) {

          readline.cursorTo(this.out, x, y);
          this.out.write(toRender[x][y]);

        }

      }

    }

    this.buffer = this.nextBuffer;
    readline.cursorTo(this.out, 0, this.height);
    this.out.write(Style.Color.Reset);

  }

  getBufferDifference(a, b) {

    let difference = this.makeBuffer(a.length, a[0].length);

    for(let x = 0; x < difference.length; x++) {

      for(let y = 0; y < difference[x].length; y++) {

        if(a[x][y] == b[x][y]) {

          difference[x][y] = this.unchangedCell;

        } else {

          difference[x][y] = b[x][y];

        }

      }

    }

    return difference;

  }

  configureOutputTerminal() {

    let _this = this;

    this.out.on("resize", function() {

      _this.updateSize();

    });

  }

}

Context.unchangedCell = undefined;

class Style {

  constructor(params) {

    params = params || {};

    this.line = params.line || "X";
    this.fill = params.fill || "O";
    this.empty = params.empty || " ";

    // Borders & Corers
    this.top = params.top || "\u2550";
    this.bottom = params.bottom || "\u2550";
    this.left = params.left || "\u2551";
    this.right = params.right || "\u2551";

    this.topLeft = params.topLeft || "\u2554";
    this.topRight = params.topRight || "\u2557";
    this.bottomLeft = params.bottomLeft || "\u255A";
    this.bottomRight = params.bottomRight || "\u255D";


    this.foreground = params.foreground || Style.Color.DefaultFG;
    this.background = params.background || Style.Color.DefaultBG;

  }

  set foreground(rgbVal) {

    if(rgbVal != Style.Color.DefaultFG) {

      this._foreground = "\x1b[38;5;" + rgbVal + "m";

    } else {

      this._foreground = rgbVal;

    }

  }

  get foreground() {

    return this._foreground;

  }

  set background(rgbVal) {

    if(rgbVal != Style.Color.DefaultBG) {

      this._background = "\x1b[48;5;" + rgbVal + "m";

    } else {

      this._background = rgbVal;

    }

  }

  get background() {

    return this._background;

  }

}

Style.Color = {

  rgb: function(r, g, b) {

    r = Math.round(r / 255 * 5);
    g = Math.round(g / 255 * 5);
    b = Math.round(b / 255 * 5);

    return 16 + r * 36 + g * 6 + b;

  },

  rgbBG: function(r, g, b) {return "\x1b[48;5;" + this.rgb(r, g, b) + "m"},
  rgbFG: function(r, g, b) {return "\x1b[38;5;" + this.rgb(r, g, b) + "m"},

  DefaultFG: "\x1b[39m",
  DefaultBG: "\x1b[49m",
  Reset: "\x1b[0m",

}

Style.Color.Black = Style.Color.rgb(0, 0, 0);
Style.Color.White = Style.Color.rgb(0, 0, 0);
Style.Color.Red = Style.Color.rgb(255, 0, 0);
Style.Color.Green = Style.Color.rgb(0, 255, 0);
Style.Color.Blue = Style.Color.rgb(0, 0, 255);
Style.Color.Yellow = Style.Color.rgb(255, 255, 0);
Style.Color.Magenta = Style.Color.rgb(255, 0, 255);
Style.Color.Cyan = Style.Color.rgb(0, 255, 255);

Style.Color.Purple = Style.Color.rgb(148, 0, 211);
Style.Color.Orange = Style.Color.rgb(255, 127, 0);


module.exports = {Context, Style}
