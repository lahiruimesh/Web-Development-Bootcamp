#!/usr/bin/env node

const cliCanvas = require("cli-canvas");
const readline = require("readline");


var stdin = process.stdin;
var stdout = process.stdout;

class App {

  constructor() {

    this.debugging = false;

    // Set up terminal
    this.ctx = new cliCanvas.Context();

    // Set up
    this.snake = [{x: Math.floor(this.ctx.width / 2), y: Math.floor(this.ctx.height / 2)}];
    this.snakeLength = 1;
    this.items = [];
    this.placeFood();
    this.d = {x: 1, y: 0};
    this.running = true;

    // Set up timewatchers
    this.methodTimes = {render: 0,moveSnake: 0};

    // Set up event handlers
    this.ctx.on("resize", this.render);

    stdin.setRawMode(true);
    stdin.resume();

    let _this = this;
    stdin.on("data", function(key) {

      if(key == '\u0003') {

        _this.quit();

      }

      _this.handleKeyPress(key);

    });

    // Start this
    this.loop();

  }

  handleKeyPress(key) {

    if(key == "\u001b[A") {key = "w"}
    if(key == "\u001b[B") {key = "s"}
    if(key == "\u001b[C") {key = "d"}
    if(key == "\u001b[D") {key = "a"}

    if(key == "w" && this.d.y == 0) {

      this.d.y = -1;
      this.d.x = 0;

      this.loop();

    } else if(key == "a" && this.d.x == 0) {

      this.d.x = -1;
      this.d.y = 0;

      this.loop();

    } else if(key == "s" && this.d.y == 0) {

      this.d.y = 1;
      this.d.x = 0;

      this.loop();

    } else if(key == "d" && this.d.x == 0) {

      this.d.x = 1;
      this.d.y = 0;

      this.loop();

    } else if(key == "v") {

      this.debugging = !this.debugging;

    }

  }

  beginTimeout() {

    let frameTime = 75;

    if(this.d.y != 0) {

      frameTime *= 2;

    }

    frameTime /= Math.pow(this.snake.length, 1/7.5);

    if(this.turbo) {

      frameTime *= 0.5;

    }

    let _this = this;
    this.timeout = setTimeout(function() {_this.loop()}, frameTime);

  }

  loop() {

    clearTimeout(this.timeout);

    this.moveSnake();
    this.render();

    if(this.running) {

      this.beginTimeout();

    }

  }

  placeFood() {

    let bonus = Math.floor(Math.random()*9) + 1;

    let spot = this.getSpot();

    this.items.push(new Item(
      spot.x,
      spot.y,
      "" + bonus,
      cliCanvas.Style.Color.Cyan,
      function(game) {

        game.snakeLength += bonus;
        game.placeFood();

      }
    ));

    spot = this.getSpot();

    let _this = this;
    let hole = new Item(
      spot.x,
      spot.y,
      Math.floor(Math.random() * 9) + 1,
      cliCanvas.Style.Color.rgb(255, 131, 0),
      function(game) {

        game.killSnake();

      }
    );

    this.items.push(hole);

    let holeInt = setInterval(function() {
      hole.icon = parseInt(hole.icon) - 1;
      if(hole.icon < 0) {
        _this.items.splice(_this.items.indexOf(hole), 1);
          clearInterval(holeInt);
      }
      }, 1000);

      spot = this.getSpot();

      if(Math.random() < 0.2) {

        let turbo = new Item(
          spot.x,
          spot.y,
          "T",
          cliCanvas.Style.Color.rgb(0, 255, 100),
          function(game) {

            game.turbo = true;
            setTimeout(function() {

              game.turbo = false;

            }, 5000);

          }
        )

        this.items.push(turbo);

      }

    }



getSpot() {

  let spot = {x: Math.floor(Math.random() * (this.ctx.width - 2) + 1), y: Math.floor(Math.random() * (this.ctx.height - 2) + 1)};

  let spotPassed = false;
  while(!spotPassed) {
    spotPassed = true;
    let spot = {x: Math.floor(Math.random() * (this.ctx.width - 2) + 1), y: Math.floor(Math.random() * (this.ctx.height - 2) + 1)};
    for(let i = 0; i < this.snake.length; i++) {
      if(this.snake[i].x == spot.x && this.snake[i].y == spot.y) {
        spotPassed = false;
      }
    }

  }

  return spot;

}

killSnake() {

  let _this = this;
  let speed = 300;
  this.running = false;

  _this.ctx.begin();
  _this.ctx.end();

  setInterval(function() {

    _this.render();

    setTimeout(function() {

    _this.ctx.begin();
    _this.ctx.end();

    }, speed / 2);

  }, speed);

  setTimeout(function() {
    _this.render();
    _this.quit()},
  speed * 5);

}

quit() {

  console.log();
  process.exit();

}

moveSnake() {

  clearTimeout(this.timeout);

  let counter = Date.now();

  // Grab the head of the snake
  let head = this.snake[this.snake.length - 1];

  // thisend to the front and grab new head
  this.snake.push({
    x: head.x + this.d.x,
    y: head.y + this.d.y
  });

  head = this.snake[this.snake.length - 1];

  // Ensure snake is in window
  if(head.x <= 0 || head.x >= this.ctx.width - 1 ||
    head.y <= 0 || head.y >= this.ctx.height - 1) {

      this.killSnake();

    }

    // Check if head intesects snake
    for(var i = 0; i < this.snake.length - 1; i++) {

      if(head.x == this.snake[i].x && head.y == this.snake[i].y ) {

        this.killSnake();

      }

    }

    // Check if head intersects an item
    for(let i = 0; i < this.items.length; i++) {

      if(head.x == this.items[i].x && head.y == this.items[i].y) {

        this.items[i].effect(this);
        this.items.splice(i, 1);
        i --;

      }

    }

    // If appropriate, decrease length of snake
    if(this.snake.length > this.snakeLength) {

      this.snake.splice(0, 1);

    }

    this.methodTimes.moveSnake = Date.now() - counter;

  }


  render() {

    let counter = Date.now();

    this.ctx.begin();

    // Render debugging
    if(this.debugging) {

      this.ctx.text(1, 1, "# Items: " + this.items.length);
      this.ctx.text(1, 2, "Length Snake: " + this.snake.length);
      this.ctx.text(1, 3, "moveSnake(): " + this.methodTimes.moveSnake + "ms");
      this.ctx.text(1, 4, "render(): " + this.methodTimes.render + "ms");

    }

    // Render border
    this.ctx.style.foreground = cliCanvas.Style.Color.DefaultFG;
    this.ctx.rect(0, 0, this.ctx.width, this.ctx.height);

    // Render Score
    let score = "Score: " + this.snake.length * 10;
    this.ctx.text(this.ctx.width - 2 - score.length, 1, score);

    // Render Items
    for(let i = 0; i < this.items.length; i++) {

      this.ctx.style.foreground = this.items[i].color;
      this.ctx.point(this.items[i].x, this.items[i].y, this.items[i].icon);

    }

    // Render snake
    this.ctx.style.foreground = cliCanvas.Style.Color.Green;
    for(var i = 0; i < this.snake.length; i++) {

      this.ctx.point(this.snake[i].x, this.snake[i].y, "O")

    }

    this.ctx.foreground = cliCanvas.Style.Color.Default;
    this.ctx.end();

    this.methodTimes.render = Date.now() - counter;

  }

}

class Item {

  constructor(x, y, icon, color, effect) {

    this.x = x;
    this.y = y;
    this.icon = icon;
    this.effect = effect;
    this.color = color;

  }

}


new App();
